Ejercicio 5

Flex no es una buena herramienta para lenguajes cuya tokenizacion no puede describirse unicamente con expresiones regulares y requiere contexto, anidamiento arbitrario o reglas dinamicas. Por ejemplo, en Python, Haskell o YAML, donde la indentacion forma parte de la sintaxis, el lexer debe mantener una pila de niveles, algo que no se expresa bien en Flex. En OCaml o lenguajes con comentarios anidados ilimitadamente, las expresiones regulares no pueden contar profundidad, obligando a programar logica manual compleja. En C/C++, la clasificacion de identificadores como tipos o variables depende de la tabla de simbolos, lo que rompe la separacion entre analisis lexico y sintactico. Tambien fallaria en lenguajes con gramatica lexica cambiante por macros o sintaxis definida por el usuario (como Racket), o con soporte Unicode avanzado donde la validez de un identificador depende de propiedades y normalizacion de caracteres. En todos estos casos, un lexer generado por Flex seria dificil de mantener y menos fiable que un escaner manual o un parser que integre el analisis lexico y sintactico.
